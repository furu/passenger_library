<p class="lead">This page lists all the configuration options available for Passenger Standalone, through either command line options or <code>Passengerfile.json</code> options.</p>

<div class="note">There is also a third, more powerful but also more complicated configuration mechanism. See the <a href="../intro.html#nginx-configuration-template">Nginx configuration template</a> for this.</div>

**Table of contents**

<ol class="toc-container"><li>Loading...</li></ol>

## Server options

### `--address` / "address"

<table class="table table-bordered table-striped">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --address <em>HOST</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"address": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_ADDRESS=<em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>0.0.0.0</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Instructs Passenger to listen for requests on the given IP address. This means that Passenger will only be able to accept requests that are sent to that IP address.

The IP address may be an IPv4 address or an IPv6 address. If you want to listen on a Unix domain socket, use [`--socket` / "socket_file"](#--socket-socket_file).

The default is to bind to 0.0.0.0, which means that Passenger can accept requests from any IPv4 address. If you use Passenger in a [reverse proxy setup](<%= url_for "/deploy/standalone/reverse_proxy.html" %>) then you should bind Passenger to 127.0.0.1, which means that only processes on the local host can access Passenger, not the public Internet.


### `--port` / "port"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --port <em>NUMBER</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"port": <em>integer</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_PORT=<em>integer</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>3000</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Instructs Passenger to listen for requests on the given TCP port number. Only has effect if you did not use [`--socket` / "socket_file"](#--socket-socket_file).


### `--socket` / "socket_file"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --socket <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"socket_file": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_SOCKET_FILE=<em>path</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Instructs Passenger to listen for requests on a Unix domain socket, not on a TCP socket. Unix domain sockets are a special kind of socket provided by the operating system, that are only usable on the local computer, not over the Internet. In return for this restricted functionality, they are highly optimized and much faster than TCP sockets.

A Unix domain socket appears as a file on the filesystem.

There are almost no web browsers and HTTP clients that support Unix domain sockets. Unix domain sockets are mainly useful if you plan on using Passenger in a [reverse proxy setup](<%= url_for "/deploy/standalone/reverse_proxy.html" %>), where you configure a reverse proxy like Nginx, running on the local machine, to forward requests to Passenger over a Unix domain socket.


### `--ssl` / "ssl"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --ssl</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"ssl": true</td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_SSL=true</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Passenger does not enable SSL</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Instructs Passenger to accept (encrypted) HTTPS requests on its socket, instead of (unencrypted) HTTP requests.

If you want Passenger to be able to listen for HTTP and HTTPS at the same time (although on different port numbers), then please use  [`--ssl-port` / "ssl_port"](#--ssl-port-ssl_port). It is not possible to make passenger listen for HTTP and HTTPS on the same port.

If this option is set, you must also set [`--ssl-certificate` / "ssl_certificate"](#--ssl-certificate-ssl_certificate) and [`--ssl-certificate-key` / "ssl_certificate_key"](#--ssl-certificate-key-ssl_certificate_key) to the SSL certificate and key files, respectively.


### `--ssl-certificate` / "ssl_certificate"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start [...] --ssl-certificate <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"ssl_certificate": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_SSL_CERTIFICATE=<em>string</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Sets the SSL certificate to use.

This option only has effect if [`--ssl` / "ssl"](#--ssl-ssl) is set.


### `--ssl-certificate-key` / "ssl_certificate_key"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start [...] --ssl-certificate-key <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"ssl_certificate_key": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_SSL_CERTIFICATE_KEY=<em>path</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Sets the SSL certificate key to use.

This option only has effect if [`--ssl` / "ssl"](#--ssl-ssl) is set.


### `--ssl-port` / "ssl_port"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start [...] --ssl-port NUMBER</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"ssl_port": <em>integer</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_SSL_PORT=<em>integer</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Instructs Passenger to listen for HTTPS requests on the given port number, while letting [the normal port number](#--port-port) listen for regular unecrypted HTTP requests.

For example, if you run the following, the Passenger will listen for HTTP requests on port 3000, while also listening for HTTPS requests on port 3005:

    passenger start --ssl --ssl-certificate ... --ssl-certificate-key ... --ssl-port 3005

This option only has effect if [`--ssl` / "ssl"](#--ssl-ssl) is set.

<div class="note">
  When in <a href="<%= url_for "/deploy/standalone/mass_deployment.html" %>">Mass Deployment mode</a>, you will probably want to set a default <code>ssl_port</code> instead of leaving this option unspecified. This is because some of your apps may contain a Passengerfile.json that contains <code>"ssl": true</code>, while others do not. In such a situation, this means that some apps want to listen for HTTPS requests on the default port, while others want to listen for unencrypted HTTP requests, which is a contradiction and causes Passenger to abort.
</div>


### `--daemonize` / "daemonize"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --daemonize</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"daemonize": true</td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_DAEMONIZE=true</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Passenger runs in the foreground</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

Instructs Passenger to daemonize into the background.


### `--user` / "user"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --user USERNAME</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"user": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_USER=<em>string</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

Instructs Passenger to drop its privilege to that of the given user as soon as Passenger has setup the socket. This only works if Passenger was started with root privileges.

If this option is not given, then Passenger runs as the user that invoked it.


### `--log-file` / "log_file"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --log-file <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"log_file": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_LOG_FILE=<em>path</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>See description</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

Log to the given log file.

The default behavior is as follows:

 1. If there is a `log` subdirectory, log to `log/passenger.XXX.log`.
 2. Otherwise, log to `passenger.XXX.log`.

In both cases, XXX is the [port number](#--port-port) that Passenger listens on.

If [`--socket` / "socket_file"](#--socket-socket_file) is set, then the default log filename does not contain the `.XXX` part.


### `--pid-file` / "pid_file"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --pid-file <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"pid_file": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_PID_FILE=<em>path</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>See description</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

Store the Passenger PID in the given PID file.

The default behavior is as follows:

 1. If there is a `tmp/pids` subdirectory, use the PID file `tmp/pids/passenger.XXX.pid`.
 2. Otherwise, use the PID file `passenger.XXX.pid`.

In both cases, XXX is the [port number](#--port-port) that Passenger listens on.

If [`--socket` / "socket_file"](#--socket-socket_file) is set, then the default PID filename does not contain the `.XXX` part.


### `--instance-registry-dir` / "instance_registry_dir"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --instance-registry-dir <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"instance_registry_dir": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_INSTANCE_REGISTRY_DIR=<em>path</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>/tmp or /var/run/passenger-instreg</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

Specifies the directory that Passenger should use for registering its current instance.

When Passenger starts up, it creates a temporary directory inside the _instance registry directory_. This temporary directory is called the _instance directory_. It contains all sorts of files that are important to that specific running Passenger instance, such as Unix domain socket files so that all the different Passenger processes can communicate with each other. Command line tools such as `passenger-status` use the files in this directory in order to query Passenger's status.

It is therefore important that, while Passenger is working, the instance directory is never removed or tampered with. However, the default path for the instance registry directory is the system's temporary directory, and some systems may run background jobs that periodically clean this directory. If this happens, and the files inside the instance directory are removed, then it will cause Passenger to malfunction: Passenger won't be able to communicate with its own processes, and you will see all kinds of connection errors in the log files. This malfunction can only be recovered from by restarting Passenger. You can prevent such cleaning background jobs from interfering by setting this option to a different directory.

This option is also useful if the partition that the temporary directory lives on doesn't have enough disk space.

The instance directory is automatically removed when Passenger shuts down.

#### Default value

The default value for this option is as follows:

 * If you are on Red Hat and CentOS, and installed Passenger through [the RPMs provided by Phusion](<%= url_for "/install/standalone/yum_repo/index.html" %>), then the default value is `/var/run/passenger-instreg`.
 * Otherwise, the default value is the value of the `$TMPDIR` environment variable. Or, if `$TMPDIR` is not set, `/tmp`.

#### Note regarding command line tools

Some Passenger command line administration tools, such as `passenger-status`, must know what Passenger's instance registry directory is in order to function properly. You can pass the directory through the `PASSENGER_INSTANCE_REGISTRY_DIR` or the `TMPDIR` environment variable.

For example, if you set 'PassengerInstanceRegistryDir' to '/my_temp_dir', then invoke `passenger-status` after you've set the `PASSENGER_INSTANCE_REGISTRY_DIR`, like this:

~~~bash
export PASSENGER_INSTANCE_REGISTRY_DIR=/my_temp-dir
sudo -E passenger-status
~~~

Notes regarding the above example:

 * The -E option tells 'sudo' to preserve environment variables.
 * If Passenger is installed through an RVM Ruby, then you must use `rvmsudo` instead of `sudo`.


### `--data-buffer-dir` / "data_buffer_dir"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --data-buffer-dir <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"data_buffer_dir": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_DATA_BUFFER_DIR=<em>path</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>See description</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

By default, Passenger buffers large web application responses. This prevents [slow HTTP clients](<%= url_for "/indepth/slow_clients.html" %>) from blocking web applications by reading responses very slowly. This feature is also known as "real-time disk-backed response buffering".

By default, such buffers are stored in the directory given by the `$TMPDIR` environment variable, or (if `$TMPDIR` is not set) the `/tmp` directory. This configuration option allows you to specify a different directory.

Changing this option is especially useful if the partition that the default directory lives on doesn't have enough disk space.

If you've specified such a directory (as opposed to using Passenger's default) then you *must* ensure that this directory exists.


## Application loading options

### `--environment` / "environment"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --environment NAME</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"environment": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_ENVIRONMENT=<em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>development</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

This option sets the value of the following environment variables:

 * `RAILS_ENV`
 * `RACK_ENV`
 * `WSGI_ENV`
 * `NODE_ENV`
 * `PASSENGER_APP_ENV`

Some web frameworks, for example Rails and Connect.js, adjust their behavior according to the value in one of these environment variables.


### `--ruby` / "ruby"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --ruby <em>COMMAND_PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"ruby": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_RUBY=<em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>The Ruby interpreter that was used for starting Passenger Standalone</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.7</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Specifies the Ruby interpreter to use for serving Ruby web applications.

<%= render_partial("/config/reference/passenger_ruby_extra_info.md", locals: locals) %>


### `--python` / "python"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --python <em>COMMAND_PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"python": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_PYTHON=<em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>The first "python" command in <a href="<%= url_for "/indepth/environment_variables.html" %>#the-path-environment-variable">the $PATH environment variable</a></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.7</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Specifies the Python interpreter to use for serving Python web applications.


### `--nodejs` / "nodejs"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --nodejs <em>COMMAND_PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"nodejs": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_NODEJS=<em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>The first "node" command in <a href="<%= url_for "/indepth/environment_variables.html" %>#the-path-environment-variable">the $PATH environment variable</a></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.7</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Specifies the Node.js/io.js comand to use for serving Node.js/io.js web applications.

Passenger's support for Node.js and io.js are the same. If you want to use io.js instead of Node.js, simply set this option to your iojs binary.


### `--meteor-app-settings` / "meteor_app_settings"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --meteor-app-settings <a href="../intro.html#relative-path-handling"><em>PATH_TO_JSON_SETTINGS_FILE</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"meteor_app_settings": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_METEOR_APP_SETTINGS=<em>string</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.7</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

When using a Meteor application in non-bundled mode, use this option to specify a JSON file with settings for the application. The `meteor run` command will be run with the `--settings` parameter set to this option.

Note that this option is not intended to be used for bundled/packaged Meteor applications. When running bundled/packaged Meteor applications on Passenger, you should set the `METEOR_SETTINGS` environment variable.


### `--rackup`

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --rackup <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Consider application a Ruby app, and use the given Rackup file instead of the default `config.ru`.

The corresponding Passengerfile.json looks as follows:

~~~json
{
  "app_type": "rack",
  "startup_file": "(your value here)"
}
~~~


### `--app-type` / "app_type"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --app-type <em>NAME</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"app_type": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_APP_TYPE=<em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td><a href="<%= url_for "/indepth/app_autodetection/index.html" %>">Autodetected</a></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.25</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

By default, Passenger [autodetects](<%= url_for "/indepth/app_autodetection/index.html" %>) the type of the application, e.g. whether it's a Ruby, Python, Node.js or Meteor app. If it's unable to autodetect the type of the application (e.g. because you've specified a custom [`--startup-file` / "startup_file"](#--startup-file-startup_file)) then you can use this option to force Passenger to recognize the application as a specific type.

Allowed values are:

<table class="table table-bordered table-striped">
  <thead>
    <th>Value</th>
    <th>Application type</th>
  </thead>
  <tbody>
    <% SUPPORTED_APP_TYPES.each do |spec| %>
      <tr>
        <td><%= spec[:type] %></td>
        <td><%= spec[:name] %></td>
      </tr>
    <% end %>
  </tbody>
</table>

#### Config file example

Use server.js as the startup file (entry point file) for your Node.js application, instead of the default app.js:

~~~json
{
  "app_type": "node",
  "startup_file": "server.js"
}
~~~


### `--startup-file` / "startup_file"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --startup-file <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"startup_file": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_STARTUP_FILE=<em>path</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td><a href="<%= url_for "/indepth/app_autodetection/index.html" %>">Autodetected</a></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.25</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

This option specifies the startup file that Passenger should use when loading the application.

Every application has a *startup file* or *entry point file*: a file where the application begins execution. Some languages have widely accepted conventions about how such a file should be called (e.g. Ruby, with its `config.ru`). Other languages have somewhat-accepted conventions (e.g. Node.js, with its `app.js`). In these cases, Passenger follows these conventions, and executes applications through those files.

Other languages have no conventions at all, and so Passenger invents one (e.g. Python WSGI with `passenger_wsgi.py`).

Passenger tries to autodetect according to the following language-specific conventions:

<table class="table table-striped table-bordered">
  <thead>
    <tr>
      <th>Language</th>
      <th>Passenger convention</th>
    </tr>
  </thead>
  <tbody>
    <% SUPPORTED_APP_TYPE_CONVENTIONS.each do |spec| %>
      <tr>
        <td><%= spec[:name] %></td>
        <td><%= spec[:startup_file] %></td>
      </tr>
    <% end -%>
  </tbody>
</table>

For other cases you will need to specify the `startup-file` manually. For example, on Node.js, you might need to use `bin/www` as the startup file instead if you are using the Express app generator.

<div class="note">
  If you set this option, you <strong>must</strong> also set <a href="#--app-type-app_type"><code>--app-type</code> / "app_type"</a>, otherwise Passenger doesn't know what kind of application it is.
</div>

#### Config file example

~~~json
{
  "app_type": "node",
  "startup_file": "server.js"
}
~~~


### `--spawn-method` / "spawn_method"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --spawn-method <em>NAME</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"spawn_method": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_SPAWN_METHOD=<em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>
      For Ruby apps: <code>smart</code><br>
      For other apps: <code>direct</code>
    </td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

This option controls whether Passenger spawns applications directly, or using a prefork copy-on-write mechanism. The [spawn methods guide](<%= url_for "/indepth/spawn_methods/index.html" %>) explains this in detail.


### `--static-files-dir` / "static_files_dir"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --static-files-dir <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"static_files_dir": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_STATIC_FILES_DIR=<em>path</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td><em>app_dir</em>/public</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.25</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

By default, Passenger automatically serves static files in the application's `public` subdirectory. Your application is offloaded from having to serve static files. In case your static files are not located in `public` but somewhere else, then use this option to specify the location.


### `--restart-dir` / "restart_dir"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --restart-dir <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"restart_dir": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_RESTART_DIR=<em>path</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td><em>app_dir</em>/tmp</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

As described in [Restarting applications](<%= url_for "/admin/#{integration_mode_type}/restart_app.html" %>), Passenger checks the file `tmp/restart.txt` in the application directory to determine whether it should restart the application. Sometimes it may be desirable for Passenger to look in a different directory instead. This option allows you to customize the directory in which `restart.txt` is searched for.

#### Example 1: default behavior

Passenger will check for /apps/foo/public/tmp/restart.txt:

    cd /apps/foo
    passenger start

#### Example 2: absolute path

An absolute filename is given. Passenger will check for /restart_files/bar/restart.txt:

    cd /apps/bar
    passenger start --restart-dir /restart_files/bar

#### Example 3: relative path

A relative filename is given. Passenger will check for /apps/baz/restart_files/restart.txt.

    cd /apps/baz
    passenger start --restart-dir restart_files


### `--friendly-error-pages`, `--no-friendly-error-pages` / "friendly_error_pages"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>
      passenger start --friendly-error-pages<br>
      passenger start --no-friendly-error-pages
    </td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"friendly_error_pages": <em>boolean</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_FRIENDLY_ERROR_PAGES=<em>boolean</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>
      <p>
        <em>When <a href="#--environment-environment"><code>--environment</code> / "environment"</a> is <code>staging</code> or <code>production</code>:</em><br>
        Friendly error pages are off
      </p>
      <p>
        <em>Otherwise:</em><br>
        Friendly error pages are on
      </p>
    </td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.42</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Passenger can display friendly error pages whenever an application fails to start. This friendly error page presents the startup error message, some suggestions for solving the problem, a backtrace and a dump of the environment variables.

This feature is very useful during application development and useful for less experienced system administrators, but the page might reveal potentially sensitive information, depending on the application. For this reason, friendly error pages are disabled by default when [--environment / "environment"](#--environment-environment) is set to `staging` or `production`, but enabled by default otherwise.

You can use this option to explicitly enable or disable this feature. `--friendly-error-pages` always enables friendly error pages, and `--no-friendly-error-pages` always disables friendly error pages. Similarly, the `"friendly_error_pages": boolean` config option always enables or disables friendly error pages.


### `--load-shell-envvars` / "load_shell_envvars"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --load-shell-envvars</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"load_shell_envvars": true</td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_LOAD_SHELL_ENVVARS=true</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Disabled</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.42</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Enables or disables the loading of shell environment variables before spawning the application.

If this option is turned on, and the user's shell is `bash`, then applications are loaded by running them with `bash -l -c`. If this option is turned off, applications are loaded by running them directly from the `Passenger core` process.


### `--debugger` / "debugger"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --debugger</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"debugger": true</td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_DEBUGGER=true</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Disabled</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

<div class="note">
  At this time, this feature is supported for Ruby applications only.
</div>

Turns support for Ruby application debugging on or off. Please read the [Ruby debugging console](<%= url_for "/admin/#{integration_mode_type}/debugging_console/ruby/index.html" %>) guide for more information.


### "envvars"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --envvar name1=value1 --envvar name2=value2 ...</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"envvars": { "name1": "value1", "name2": "value2", ... }</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>
      Command line syntax: since 5.0.22<br>
      Config file syntax: since 5.0.1
    </td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Sets arbitrary environment variables for the application.


## Process management options

<a name="passenger_max_instances"></a>

### `--max-pool-size` / "max_pool_size"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --max-pool-size <em>NUMBER</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"max_pool_size": <em>integer</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_MAX_POOL_SIZE=<em>integer</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>6</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

The maximum number of application processes that may simultaneously exist. A larger number results in higher memory usage,
but improves the ability to handle concurrent HTTP requests.

The optimal value depends on your system's hardware and your workload. Please read the [optimization guide](<%= url_for "/config/#{integration_mode_type}/optimization/index.html" %>) to learn how to find out the optimal value.

If you find that your server is running out of memory then you should lower this value. In order to prevent your server from crashing due to out-of-memory conditions, the default value is relatively low (6).


### `--min-instances` / "min_instances"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --min-instances <em>NUMBER</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"min_instances": <em>integer</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_MIN_INSTANCES=<em>integer</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>1</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

This specifies the minimum number of application processes that should exist for a given application. You should set this option to a non-zero value if you want to avoid potentially long startup times after a website has been [idle](#--pool-idle-time-pool_idle_time) for an extended period of time.

#### Example

Suppose that you have the following configuration:

~~~json
{
  "max_pool_size": 15,
  "pool_idle_time": 10
  "min_instances": 3
}
~~~

When you start Passenger, it spawns 3 application processes. Suppose that there's a sudden spike of traffic, and 100 users visit 'foobar.com' simultaneously. Passenger will start 12 more application processes (`15 - 3 = 12`). After the idle timeout of 10 seconds has passed, Passenger will clean up 12 application processes, keeping 3 processes around.


### `--pool-idle-time` / "pool_idle_time"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --pool-idle-time <em>SECONDS</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"pool_idle_time": <em>integer</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_POOL_IDLE_TIME=<em>integer</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>300 <em>(5 minutes)</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

The maximum number of seconds that an application process may be idle. That is, if an application process hasn't received any traffic after the given number of seconds, then it will be shutdown in order to conserve memory.

Decreasing this value means that appliction processes will have to be spawned more often. Since spawning is a relatively slow operation, some visitors may notice a small delay when they visit your web app. However, it will also free up resources used by the processes more quickly.

The optimal value depends on the average time that a visitor spends on a single dynamic page. We recommend a value of `2 * x`, where `x` is the average number of seconds that a visitor spends on a single dynamic page. But your mileage may vary.

When this value is set to `0`, application processes never not be shutdown (unless they crash or are manually killed, of course).

Setting the value to 0 is recommended if you favor resource savings more than predictable performance.


### `--max-preloader-idle-time` / "max_preloader_idle_time"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --max-preloader-idle-time <em>SECONDS</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"max_preloader_idle_time": <em>integer</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_MAX_PRELOADER_IDLE_TIME=<em>integer</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>300 <em>(5 minutes)</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

The preloader process (explained in [Spawn methods](<%= url_for "/indepth/spawn_methods/index.html" %>)) has an idle timeout, [just like the application processes spawned by Passenger do](#--pool-idle-time-pool_idle_time). That is, it will automatically shutdown a preloader process if it hasn't done anything for a given period.

This option allows you to set the preloader's idle timeout, in seconds. A value of `0` means that it should never idle timeout.

Setting a higher value will mean that the preloader is kept around longer, which may slightly increase memory usage. But as long as the preloader server is running, the time to spawn a Ruby application process only takes about 10% of the time that is normally needed, assuming that you're using the `smart` [spawn method](#--spawn-method-spawn_method). So if your system has enough memory, then is it recommended that you set this option to a high value or to `0`.


<a name="passenger_concurrency_model"></a>

### `--concurrency-model` / "concurrency_model"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --concurrency_model <em>&lt;process|thread&gt;</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"concurrency_model": <em>"process"|"thread"</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_CONCURRENCY_MODEL=<em>process|thread</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>process</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
  <%= render_partial("/config/reference/enterprise_only.html") %>
</table>

Specifies the I/O concurrency model that should be used for Ruby application processes. Passenger supports two concurrency models:

 * `process` -- single-threaded, multi-processed I/O concurrency. Each application process only has a single thread and can only handle 1 request at a time. This is the concurrency model that Ruby applications traditionally used. It has excellent compatiblity (can work with applications that are not designed to be thread-safe) but is unsuitable for workloads in which the application has to wait for a lot of external I/O (e.g. HTTP API calls), and uses more memory because each process has a large memory overhead.
 * `thread` -- multi-threaded, multi-processed I/O concurrency. Each application process has multiple threads (customizable via [`--thread-count` / "thread_count"](#--thread-count-thread_count). This model provides much better I/O concurrency and uses less memory because threads share memory with each other within the same process. However, using this model may cause compatibility problems if the application is not designed to be thread-safe.

<div class="note">
  <ul>
    <li>This option only has effect on Ruby applications.</li>
    <li>Multithreading is not supported for Python.</li>
    <li>Multithreading is not applicable to Node.js, io.js and Meteor because they are evented and do not need (and cannot use) multithreading.</li>
  </ul>
</div>


<a name="passenger_thread_count"></a>

### `--thread-count` / "thread_count"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start [...] --thread-count <em>INTEGER</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"thread_count": <em>integer</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_THREAD_COUNT=<em>integer</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>1</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Specifies the number of threads that Passenger should spawn per Ruby application process. This option only has effect if [`--concurrency-model` / "concurrency-model"](#--concurrency-model-concurrency_model) is `thread`.

<div class="note">
  <ul>
    <li>This option only has effect on Ruby applications.</li>
    <li>Multithreading is not supported for Python.</li>
    <li>Multithreading is not applicable to Node.js, io.js and Meteor because they are evented and do not need (and cannot use) multithreading.</li>
  </ul>
</div>


### `--rolling-restarts` / "rolling_restarts"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --rolling-restarts</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"rolling_restarts": true</td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_ROLLING_RESTARTS=true</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Disabled</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
  <%= render_partial("/config/reference/enterprise_only.html") %>
</table>

Enables or disables support for [zero-downtime application restarts](<%= url_for "/deploy/standalone/zero_downtime_redeployments/index.html" %>) through `restart.txt`.

Please note that this option is completely unrelated to the `passenger-config restart-app` command. That command always initiates a blocking restart, unless `--rolling-restart` is given.


### `--resist-deployment-errors` / "resist_deployment_errors"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --resist-deployment-errors</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"resist_deployment_errors": true</td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_RESIST_DEPLOYMENT_ERRORS=true</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Disabled</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
  <%= render_partial("/config/reference/enterprise_only.html") %>
</table>

Enables or disables [resistance against deployment errors](<%= url_for "/deploy/standalone/deployment_error_resistance.html" %>).

Suppose that you have upgraded your application and you have issued a command to restart it, but the application update contains an error (e.g. a syntax error or a database configuration error) that prevents Passenger from successfully spawning a process. Passenger would normally display an error message to the visitor in response to this.

By enabling deployment error resistance, Passenger Enterprise would "freeze" the application's process list. Existing application processes (belonging to the previous version) will be kept around to serve requests. The error is [logged](<%= url_for "/admin/#{integration_mode_type}/log_file/log_file.html" %>), but visitors do not see any error messages. Passenger keeps the old processes around until an administrator has taken action. This way, visitors will suffer minimally from deployment errors.

[Learn more about this feature in Deployment Error Resistance guide](<%= url_for "/deploy/standalone/deployment_error_resistance.html" %>).

Note that enabling deployment error resistance only works if you perform a [rolling restart instead of a blocking restart](<%= url_for "/admin/standalone/restart_app.html" %>#blocking-restart-vs-zero-down-time-restart-(rolling-restart)).


## Request handling options

### `--max-request-time` / "max_request_time"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --max-request-time <em>SECONDS</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"max_request_time": <em>integer</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_MAX_REQUEST_TIME=<em>integer</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>0</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
  <%= render_partial("/config/reference/enterprise_only.html") %>
</table>

The maximum amount of time, in seconds, that an application process may take to process a request. If the request takes longer than this amount of time, then the application process will be forcefully shut down, and possibly restarted upon the next request. A value of 0 means that there is no time limit.

This option is useful for preventing your application from getting stuck for an indefinite period of time.

<div class="note">
  This option should be considered as a workaround for misbehaving applications. It is advised that you fix the problem in your application rather than relying on this option as a measure to avoid stuck applications.
</div>


### `--sticky-sessions` / "sticky_sessions"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --sticky-sessions</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"sticky_sessions": true</td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_STICKY_SESSIONS=true</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Disabled</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.1</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

When sticky sessions are enabled, all requests that a client sends will be routed to the same originating application process, whenever possible. When sticky sessions are disabled, requests may be distributed over multiple processes, and may not necessarily be routed to the originating process, in order to balance traffic over multiple CPU cores. Because of this, sticky sessions should only be enabled in specific circumstances.

For applications that store important state inside the process's own memory -- that is, as opposed to storing state in a distributed data store, such as the database or Redis -- sticky sessions *should* be enabled. This is because otherwise, some requests could be routed to a different process, which stores different state data. Because processes don't share memory with each other, there's no way for one process to know about the state in another process, and then things can go wrong.

One prominent example is the popular [SockJS library](http://sockjs.org/), which is capable of emulating WebSockets through long polling. This is implemented through two HTTP endpoints, `/SESSION_ID/xhr_stream` (a long polling end point which sends data from the server to the client), and `/SESSION_ID/xhr_send` (a normal POST endpoint which is used for sending data from the client to the server). SockJS correlates the two requests with each other through a session identifier. At the same time, in its default configuration, it stores all known session identifiers in an in-memory data structure. It is therefore important that a particular `/SESSION_ID/xhr_send` request is sent to the same process where the corresponding `/SESSION_ID/xhr_stream` request originates from; otherwise, SockJS cannot correlate the two requests, and an error occurs.

So prominent examples where sticky sessions should (or even *must*) be enabled, include:

 * Applications that use the SockJS library (unless configured with a distributed data store)
 * Applications that use the Socket.io library (unless configured with a distributed data store)
 * Applications that use the faye-websocket gem (unless configured with a distributed data store)
 * Meteor JS applications (because Meteor uses SockJS)

Sticky sessions work through the use of a special cookie, whose name can be customized with [`--sticky-sessions-cookie-name` / "sticky_sessions_cookie_name"](#--sticky-sessions-cookie-name-sticky_sessions_cookie_name). Passenger puts an identifier in this cookie, which tells Passenger what the originating process is. Next time the client sends a request, Passenger reads this cookie and uses the value in the cookie to route the request back to the originating process. If the originating process no longer exists (e.g. because it has crashed or restarted) then Passenger will route the request to some other process, and reset the cookie.

If you have a load balancer in front end of Passenger + Nginx, then you must configure sticky sessions on that load balancer too. Otherwise, the load balancer could route the request to a different server.


### `--sticky-sessions-cookie-name` / "sticky_sessions_cookie_name"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --sticky-sessions-cookie-name <em>NAME</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"sticky_sessions_cookie_name": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_STICKY_SESSIONS_COOKIE_NAME=<em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>_passenger_route</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.1</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main, per-app</td>
  </tr>
</table>

Sets the name of the [sticky sessions](#--sticky-sessions-sticky_sessions) cookie.


### `--disable-turbocaching` / "turbocaching"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --disable-turbocaching</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"turbocaching": false</td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_TURBOCACHING=false</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Enabled</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.14</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

Disables [turbocaching](<%= url_for "/indepth/turbocaching.html" %>).


## Nginx engine options

### `--nginx-config-template` / "nginx_config_template"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --nginx-config-template <a href="../intro.html#relative-path-handling"><em>PATH</em></a></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"nginx_config_template": <em>string</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_NGINX_CONFIG_TEMPLATE=<em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Enabled</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.1</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

Instructs Passenger Standalone's [Nginx engine](<%= url_for "/indepth/standalone_engines.html" %>) to use a specific Nginx config template, instead of the default. Learn more about this in the [configuration introduction](<%= url_for "/config/standalone/intro.html" %>#nginx-configuration-template).

Please note that this option only works if Passenger Standalone is [configured](#--engine-engine) to use the [Nginx engine](<%= url_for "/indepth/standalone_engines.html" %>).

<div class="warning">
  <h3 class="notoc">The Nginx config file must follow a specific format</h3>
  <p>You can't just use any arbitrary Nginx config file! The Nginx config file you pass to Passenger Standalone *must* be based on the one provided by Passenger Standalone. Learn more about this in the <a href="<%= url_for "/config/standalone/intro.html" %>#nginx-configuration-template">configuration introduction</a>.</p>
</div>

<div class="note">
  <h3 class="notoc">Keep your configuration template up to date</h3>
  <p>The original configuration template file may change from time to time, e.g. because new features are introduced into Passenger. If your configuration template file does not contain the required changes, then these new features may not work properly. In the worst case, Passenger Standalone might even malfunction. Therefore, every time you upgrade Passenger, you should check whether the original configuration template file has changed, and merge back any changes into your own file.</p>
</div>


## Advanced options

### `--engine` / "engine"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --engine <em>nginx|builtin</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"engine": <em>"nginx"|"builtin"</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_ENGINE=<em>nginx|builtin</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>nginx</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

Sets the Passenger Standalone engine to use. [Learn more about Passenger Standalone engines.](<%= url_for "/indepth/standalone_engines.html" %>)


### `--log-level` / "log_level"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --log-level <em>NUMBER</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"log_level": <em>integer</em></td>
  </tr>
  <tr>
    <th>Environment variable syntax</th>
    <td>PASSENGER_LOG_LEVEL=<em>integer</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>3</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

This option allows one to specify how much information Passenger should write to the log file. A higher log level value means that more information will be logged.

Possible values are:

 * `0` (crit): Show only critical errors which would cause Passenger to abort.
 * `1` (error): Also show non-critical errors -- errors that do not cause Passenger to abort.
 * `2` (warn): Also show warnings. These are not errors, and Passenger continues to operate correctly, but they might be an indication that something is wrong with the system.
 * `3` (notice): Also show important informational messages. These give you a high-level overview of what Passenger is doing.
 * `4` (info): Also show less important informational messages. These messages show more details about what Passenger is doing. They're high-level enough to be readable by users.
 * `5` (debug): Also show the most important debugging information. Reading this information requires some system or programming knowledge, but the information shown is typically high-level enough to be understood by experienced system administrators.
 * `6` (debug2): Show more debugging information. This is typically only useful for developers.
 * `7` (debug3): Show even more debugging information.


### `--ctl` / "ctls"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --ctl <em>var1=value1</em> <em>var2=value2</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"ctls": [ "var1=value1", "var2=value2", ... ]</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>3</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
  <tr>
    <th><a href="../intro.html#context-specific-configuration">Mass deployment context</a></th>
    <td>Main</td>
  </tr>
</table>

Low-level mechanism to set arbitrary internal options.
